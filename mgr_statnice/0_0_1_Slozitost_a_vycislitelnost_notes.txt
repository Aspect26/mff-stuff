Výpočetní modely (Turingovy stroje, RAM).
- turingův stroj 
    - Q: stavy, E: abeceda (včetně prázdného znaku), d: QxE->QxEx{R,N,L} přechodová funkce, q0 z Q: počáteční stav, F <= Q: přijímací stavy
    - konfigurace: (stav, slova vlevo, slova vpravo)

    - na pásce vstup, mimo něj prázdné znaky, hlava na prvním políčku, ... 
    - podle aktuálního znaku a stavu se vybere přechodová funkce, zapíše se její result na aktuální políčko, změní stav, a přesune se Left, Right, Nowhere
        - pokud není validní přechod - výpočet končí
    
    - TS M přijímá slovo w: výpočet končí a po ukončení se M nachází v přijímacím stavu 
        - množina přijímaných slov: L(M)
    - TS M odmítá slovo w: výpočet končí a po ukončení se M nenachází v přijímacím stavu 
    - TS M konverguje nad w: výpočet končí 
    - TS M diverguje nad w: výpočet nekončí 
    
    - varianty TS:  
        - jednosměrné s nekonečnou páskou
        - více páskami 
        - více hlavami na více paskách (spojené hlavy/nezávislé)
        - pouze binární abecedou 
        - nedeterministické TS 

        -> všechny jsou ekvivalentní našemu TS: přijímají stejnou třídu jazyků a vyčislují tutež třídu funkcí 

    - k-páskový TS
        - každá páska má hlavu zvlášť 
        - vstupní páska: vstup, jen čtení
        - výstupní páska: výstup, prázdná na začátku, jen zápis 
        - pomocní pásky: prázdné na začátku, read/write 
        -  QxE^k->QxE^kx{R,N,L}^k

        - ekvivalentní jednopáskovému
            - pásky interleavneme na jednu pásku 
            - pozice hlav označujeme speciálním znakem 
            - nová abeceda: kartézský součin původních k abeced + pozice hlav 
- RAM 
    - výpočetní stroj s náhodným přístupem do paměti 
    - neomezená paměť "pole" 
    - LOAD, ADD, SUB, COPY, JNZ, READ, PRINT 
        - přímá/nepřímá adresace 
        - load načte 0 -> konec vstupu 

    - RAM přijme: ukončí a první číslo které zapíše na výstup je 1 
    - RAM odmítne: stejné ale 0 
    
    - rozhodovatelné jazyky, vyčislitelné funkce, ..., stejné jako u TS 

- ekvivalence RAM a TS: 
    - TS->RAM 
        - obsah pásky uložen ve dvou polích Tr, levá a pravá část pásky 
        - poloha hlavy v proměnné h, stav v proměnné q
        - výběr instrukce: podle h, q
            - ~velký switch na odpovící branch přechodové funkce 

    - RAM->TS: 
        - čtyřpáskový TS, binárně zapsaná čísla && oddělení #
        - vstupní páska: data, co má RAM dostat na vstupu 
        - výstupní páska: ekvivalent 
        - paměť RAM: obsah paměti 
        - pomocná páska: mezivýpočty, ... 
        
- churchill turingova teze
    - ke každému algoritmu v intuitivním smyslu existuje ekvivalentní Turingův stroj 

- Gödelovo číslo: 
    - chceme TS přiřadit číslo 
    - mějme TS M s jediným přijímacím stavem, binární vstupní abecedou (každý TS lze převést do této podoby)
    - potřeba zakodovat přechodovou funkci: 
        - abeceda: 0, 1, L, N, R, |, #, ; 
        - qi Xj -> qk, Xl, Z :: i | j | k | l | Z 
        - jednotlivé instrukce za sebou C1#C2#C3... 
        - převedeme do binarního zapisu jednoznačně: 0->000, 1->001, ..., #->110, ...

    -> každému TS M lze přiřadit číslo. 
        - pokud číslo není validní zakodování, řekneme, že odpovídá prázdnému TS, který vše odmítne 
        -> každému TS M odpovídá číslo, každému číslu TS M 
        - kód TS není jednoznačný (pořadí např. instrukcí)

- universální TS: 
    - vstupem je U: <M, x>, kde M je TS a x řetězec 
    - U simuluje x na M 

    - jazyk: universální jazyk Lu
    - TS: 3 páskový 
        - první páska vstup 
        - druhá páska obsah pracovní pásky M 
        - aktuální stav M 

Rozhodnutelné a částečně rozhodnutelné problémy   
- turingovsky rozhodnutelné jazyky
    - jazyk je rozhodnutelný (rekurzivní) pokud existuje TS M, který se vždy zastaví a L=L(M)
    - jazyk je částečně rozhodnutelný (rekurzivně spočetný) existuje-li M: L=L(M)

- turingovsky vyčíslitelné funkce:
    - TS M nad abecedou E počítá částečnou (def. jen pro některé vstupy) funkci fM: E*->E*:
        - pokud M(w) konverguje: je fM(w) definovaná a hodnota je slovo na pásce po ukončení výpočtu 
        - pokud M(w) diverguje: je fM(w) nedefinovaná
    - funkce f: je turingovsky vyčíslitelná pokud existuje TS M,který ji počítá 
        - každá tur. vyčíslitelná funkce má nekonečně strojů, které ji počítají 

- rekurzivní a rekurzivně spočetné množiny
    - základní funkce: 
        - konstantní funkce o(x) = 0
        - funkce následníka s(x) = x+1
        - projekce: I_n_j(x1...xn) = xj 

    - operátory: 
        - substituce: h(x1...xn) = f(g1(x1...xn), ..., gm(x1...xn)) : volání procedur
        - primitivní rekurze:  h(x1...xn) = f(x2...xn) if x == 0 else g(x1-1, h(x1-1, ..., xn), x2, ..., xn) : for cyklus 
        - minimalizace: h(x1...xn) = min {y | f(x1..xn, y) = 0 and Vz <= y f(x1...xn, z) konverguje} : for cyklus : while cyklus

    - primitivně rekurzivní funkce: základní funkce, substitutuce a primitivní rekurze 
    - částečně rekurzivní funkce: základní funkce, substitutuce, primitivní rekurze, minimalizace
    - obecně rekurzivní funkce: ČRF, která je všude definovaná tj. všude konverguje 

    - primitivně/obecně/rekurzivně spočetný predikát: relace s odpovídající ^^ rekurzivní funkcí jako charakteristickou funkcí 
        - odpovídá jazykům definovaným pro TS výše 
    
    - ekvivalence TS a ČRF 

- vlastnosti rozhodnutelných jazyků
    - jsou li L1, L2 (částečně) rozhodnutelné jazyky
        - průniky, sjendocení, konkatenace, iterace jsou (částečně) rozhodnutelné jazyku

    - postova věta: je-li L rozhodnutelný <> L a L' jsou částečně rozhodnutelné 
        -> prohodím přijímající / nepřijímající stavy 
        <- paralelní běh ML a ML', jeden z nich určitě jednou přijde -> můžu zastavit a přijmout/odmítnout 

- vlastnosti částečně rozhodnutelných jazyků
    - pro jazyk L <= E* jsou násl. ekvivalence 
        - L je částečně rozhodnutelný 
        - existuje TS Me, který se právě pro každé x z L zastaví 
        - existuje rozhodnutelný jazyk B: L = {x z L | E y z E* | <x, y> z B}
            - např. počet kroků, mohu pak simulovat a po překročení odmítnout 

- enumerátory: pro jazyk L je to turingův stroj E 
    - ignoruje vstup 
    - během výpočtu vypisuje řetězce w z L 
    - každý řetězec z L je někdy vypsán
    - pokud je L nekonečný tak E nikdy neskončí 
    
    - jazyk je částečně rozhodnutelný <> existuje enumerátor E 
        -> generuju slova lexikograficky do délky "d", spouštím ts pro počet "k"roků, iterarivně obojí zvyšujeme   
        <- čekám než iterátor vypíše slovo, pak přijmu
    - jazyk je rozhodnutelný <> existuje enumerátor E v lexikografickém pořadí 
        -> zkouším slova v lexigorafickém prostředí, výpočet vždy skončí -> vypisuju když přijmou
        <- počkám než vypíše slovo za aktuálním -> přijmu/nepřijmu


- převoditelnsot: 
    - jazyk A je m-převoditelný na jazyk B pokud existuje `totální vyčíslitelná funkce` f: Vx z E* [x z A <> f(x) z B]
    - jazyk A je m-úplný pokud je A částečně rozhodnutelný a každý částečně rozhodnutelný jazyk je na něj převoditelný 

    - Lu, Lhalt, jsou m-úplné 


Algoritmicky nerozhodnutelné problémy (halting problem)
- Riceova věta 
    - nechť C je třída částečně rozhodnutelných jazyků, Lc = {<M> | L(M) z C}, pak Lc je rozhodnutelný právě pokud je C triviální třída (vše/nic)
    - spor: mějme netriviální třídu C, Mc je TS pro Lc, který (z rozhodovatelnsoti) vždy konverguje 
    - zvolme jazyk z C přijímaný TS N
    - vytvořme TS M, který na vstup pustí vlastní kód <M> a pokud se zastaví, tak spustí stroj N s původním vstupem 
        - pokud M(<M>) konverguje -> L(M) == L(N)
                                  -> <M> z Lc
        - pokud M(<M>) diverguje -> <M> !z Lc 
        -> pomocí Mc ověřím jestli Mc(<M>), tj. jestli je <M> z Lc, čímž rozhodnu jestli <M> neupravený haltuje 
        -> dá se rozhodovat jazyk K = <M> | M(<M>) zastaví -> spor protože je nerozhodnutelný

- množství jazyků:
    - různých jazyků je nespočetně mnoho: podmnožina E* (~odp. přirozeným číslům)
    - částečně rozhodnutelných jazyků max spočetně: pro každý existuje TS M, TS lze zakodovat viz. gödelovo číslo -> spočetně mnoho 
    -> existuje nespočetně nerozhodnutelných jazků 

- diagonalizační jazyk: není ani částečně rozhodnutelný
    - Ldiag {<M> | <M> !z L(M)} // stroje, které sami nepřijímají vlastní kód 
    - dk: sporem: nechť Ml přijímá: 
        - řekněme, že <Ml> z Ldiag -> Ml musí přijmout <Ml> -> dle definice spor 
        - řekněme, že <Ml> !z Ldiag -> přijme se -> musí být z jazyka -> spor 
    - Ldiag' je částečně rozhodnutelný: skrze universální TS, díky Postově větě ale nemůže být rozhodnutelný 

- universální jazyk je částečně rozhodnutelný, ale ne rozhodnutelný 
    - je částečně rozhodnutelný neb existuje universální turingův stroj 
    - kdyby byl rozhodnutelný, tak dle postuli věty je Lu' částečně rozhodnutelný -> , má TS M
    - Lu' = L(M) = <M,x> | x !z L(M) má TS M
    - vytvořme M' pomocí M na částečné rozhodnutí Ldiag:
        - pokud na vstupu e ne-ok TS, odmítnu 
        -> přijme právě pokud náleží do Ldiag -> nelze, protože není částečně rozhodnutelný -> spor 

- halting problem: jazyk všech <M, x> které zastaví je částečně rozhodnutelný ale ne rozhodnutelný 
    - částečná rozhodnutelnost plyne s existence universálního Mu (pro Lu)
    - předpokládejme rozhodnutelnost Lhalt' je částečně rozhodnutelný (postova věta), má TS M 
    - definujme L' = <M> | M(<M>) nezastaví, postavme M' pomocí M který částečně rozhoduje L'
        - pokud vstup e není validní TS, odmítne 
        - spustí M s <e,e>, pokud přijme, tak přijme; jinak se zacyklí -> přijme svůj stup právě když se zastaví -> L(M') = diagonala Lhalt' = L'
        -> pokud <M'> z L' ->  M' se na <M'> musí zastavit -> z definice L' se M'(<M'>) nemá zastavit -> spor 
        -> pokud <M'> !z L' ->  podle definice L' M'(<M'>) zastaví -> dle popsání M' ale přijme, z čehož vyplývá <M'> z L' -> spor 



Nedeterministický výpočetní model
- nedeterministický TS: d: QxE -> P(QxEx{L, N, R})
    - NTS M v každém kroku uhodne/vybere správnou instrukci 
    - NTS M vykoná všechny možné instrukce současně / je ve všech konfiguracích najednou 

- stejná výpetní síla jako normální TS ~ stejně silný w.r.t to Churchov-Turing teze 
    - kartezsky soucin stavu
    - iterative deepening simulace 
- výpočet NTS M 
    - posloupnost konfigurací C0, C1, ... Cn 
    - přechody jen možné, přijímající pokud konečný & stav příjímající, ... 

Základní třídy složitosti a jejich vztahy
- typy problému:
    - rozhodovací problémy: ptáme se zda instance x má nějakou vlastnost, jazyk kladných instancí L <= E*, query: x z L 
    - uloha pro danou instanci x: hledáme y, které suplňuje určitou podmínku -> hledání y z relace R <= E*xE* 
    - optimalizační úloha: hledáme takové y, které minimalizuje externí míru 

- časová a prostorová složitost 
    - nechť M je TS M, f: N->N funkce 
    - M pracuje v čase f(n): každý výpočet M nad libovolným vstupem x |x|=n skončí po provedení nejvýše f(n) kroků 
    - M pracuje v prostoru f(n): každý výpočet M nad libovolným vstupem x |x|=n využije maximálně f(n) buněk pracovní pásky 

    - NTIME(f(n)): třída jazyků přijímaných nedetermministickým TS, které pracují v čase O(f(n))
    - TIME(f(n)): třída jazyků přijímaných determministickým TS, které pracují v čase O(f(n))
    - NSPACE(f(n)): třída jazyků přijímaných nedetermministickým TS, které pracují v paměti O(f(n))
    - SPACE(f(n)): třída jazyků přijímaných determministickým TS, které pracují v paměti O(f(n))

    - NP: U_k€N NTIME(n^k) : přijímané nedeterministickým turing. v polynomiálním čase
    - P: U_k€N TIME(n^k) : přijímané deterministickým turing. v polynomiálním čase 

    - EXPTIME: U_k€N TIME(2^n^k)

- polynomiální třídy: 
    - nerostou příliš rychle 
    - jsou uzavřené na skládání 
    - silnější Curchil-Turing: každý rozumný a obecný výpočet lze na TS simulovat s polynomiálním zpomalením/zvětšením potřebného prostoru  
        - P/PSPACE nezávislé na zvoleném výpočetním modelu / prog. jazyce 
    
- třída NP 
    - verifikátor pro jazyk L je algoritmus V: L = {x| Ey V přijme(x, y)}
        - polynomiální verifikátor: pracuje v polynomiálním čase vůči |x|
        - pokud má y pol(x) délku: polynomiální certifikát 
    -> NP: třída jazyků s polynomiálními verifikátory 
    
    - ekvivalence definic
        -> existuje poly. verif: 
            - NTS Ml první nedeterministicky uháhne 'y' 
                - lze, prostě má přechody pro každý možný znak, lineárně uhádne celý
            - odsimiluje dle předpokladů existující Mb pro funkci B 
        <- jako 'y' můžeme brát jakou ze všech možných (nedeterministicky zvolených) předodů NTM vybere 
            - maximálně polynomálně moc kroků -> y max polynomiálně dlouhé 

- modely s menším než lineráním space/time 
    - potřeba mít více pásek: vstupní, výstupní, pracovní  
    - do času a prostoru pouze pracovní páska 
    - konfigurace neobsahuje vstupní slovo 

    - L: SPACE(log2n)
    - NL: NSPACE(log2n)
    - NPSPACE: Uk NSPACE(n^k)

- pro každou f: platí, že 
    - TIME(f(n)) <= SPACE(f(n)): 
        - nelze popsat víc buněk než kolik je času (sublineární: třeba nepočítat vstup, viz výše)
    - TIME(f(n)) <= NTIME(f(n)) <= SPACE(f(n)) <= NSPACE(f(n))
        - první a třetí triviálně 
        - druhá: simulujeme, max const možností/paměti per krok, tj. f(n)*const paměti pro backtrack záznam 

- f(n) funkce f(n) >= log(n), pro každý L z NSPACE(f(n)) existuje L z TIME(2^(cl * f(n)))
    - počet konfigurací je omezen 2^(cl * f(n)) -> odhad času (přijímací výpočet se v každé konfiguraci ocitne jen jednou else zacyklení)

- platí inkluze: L <= P <= NP <= PSPACE <= NPSACE <= EXPTIME 

- savičova věta: pro každou fn > logn vyčíslitelnou v prostoru O(f(n)) :: NSPACE(f(n)) <= SPACE(f^2(n))
    - počet konfigurací je omezen 2^(cl * f(n))
    - skrz dynamické progrmaování a půlení (vždy zafixujeme mid-bod, hledáme cestu k němu a od něj) procházíme grafem (pouze unikátní konfigurace) všech možných konfigurací
        - v každém volání zafixujeme/otestujeme 1 konfiguraci a zavoláme se na 2 pod-problémy -> celkem 2^f(n) zafixovaných bodů 
        - hloubka rekurze: O(f(n)) 
        - jedna instance O(f(n))
        -> O(f^2(n))

    -> PSPACE = NPSPACE 

Věty o hierarchii
- f: N->N f(n)>logn je prostorově konstruovatelná, pokud zobrazuje 1^n na binární representaci f(n) a je vyčíslitelná v prostoru O(f(n))
    - f vyčíslitelná v prostoru O(f(n)): existuje TS, který pracuje v prostoru O(f(n)) na vstupem 1^n a po ukončení je zapsán řetězec 1^f(n) 
    - ~odpovídá zarezervování prostoru, není každá funkce, většina ano 

- věta o prostorové hierarchii 
    - pro každou prostorově konstruovatelnou funkci f: E L rozhodnutelný v prostoru O(f(n)) ale ne o(f(n))
    - L = <M>, 10^k | M odmítá <<M>, 10^k> v prostoru <= f(|<<M>, 10^k>|)
    - rozhodnutelné v prostoru O(f(n))
        - pro vstup x, |x| = n, spocti f(n), označ dost buněk na pásce, pokud alg. zkusí označit víc buněk -> odmítni
        - pokud x není validního tvaru, odmítni 
        - simuluj běh M na x, pokud přesáhne f(n) prostoru nebo 2^f(n) času (viz odhad konfigurací, řeší zacyklení, na počítání času stačí log(2^fn)) == fn prostoru, odmítni 
        - pokud M přijme, odmítni, jinak přijmi 
    - L je nerozhonutelný v prostoru o(f(n)): sporem, mějme TS M rozhoduje L, slovo w <<M>, 10^k>
        - w z L <> M přijme w <> M nepřijímá <<M>, 10^k> v prostoru <= f(|<<M>, 10^k>|) <> spor s předpokladem že `M přijme w` `v prostoru o(f(n))`
        - uplatňuje se 10^k, kdyby tam nebylo tak velikost vstupu pouze |M|, celá práce se musí vejít do O(|M|)
        - 10^k nám poskytuje prostor pro práci -> zajišťuje, že odmítnutí není kvůli překročení prostoru z důvodu simulace (tj. kde by M nativně nepřekročilo)

    - důsledky
        - jsou li f1, f2; f1 z o(f2); f2 prostorově konstruovatelná: SPACE(f1) < SPACE(f2) 
        - e1 < e2 : SPACE(n^e1) < SPACE(n^e2)
        - NL < PSPACE < EXPSPACE

- věta o časové prostorové hierarchii 
    - pro každou časově. konstr. funkci f existuje jazyk A, rozhonutelný v O(f(n)) ale ne o(f(n)/log(f(n)))
    - faktor log(f(n)) navíc neb TS simulující důkaz si musí pamatovat konfiguraci stroje, který simuluje  

    - L = <M>, 10^k | M neprijima <M>, 10^k v case <= f(n) / log(f(n))
    - L rozhodnutelný v čase O(f(n)):
        - pro vstup x spočti f(n)
        - pokud x není v korektním tvaru, odmítni 
        - Simuluj M na vstupu x, pokud nedoběhne v f(n) / log(f(n)) krocích, odmítni 
        - Pokud přijme odmítni, jinak přijmi

        - každý krok je třeba snížit čítač: v každém kroku simulace max O(log(f(n))) práce (max délka) -> náročnost simulace je O(f(n))
    - L není rozhodnutelný v o(f(n) / log(f(n)))
        - nechť je v daném čase rozhodnutelný pomocí TS M, slovo w = <M>, 10^k 
        - w z L <> w přijmuté M v `o(f(n) / log(f(n)))` <> spor s definicí `M neprijima <M>, 10^k v case <= f(n) / log(f(n))`

    - důsledky
        - jsou li f1, f2; f1 z o(f2/logf2n); f2 prostorově konstruovatelná: TIME(f1) < TIME(f2) 
        - TIME(n^e1) < TIME(n^e2)
        - P < EXPTIME

Úplné problémy pro třídu NP, Cook-Levinova věta
Pseudopolynomiální algoritmy, silná NP-úplnost

Aproximační algoritmy a schémata
